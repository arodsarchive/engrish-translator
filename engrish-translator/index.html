<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Engrish Translator – Birrion Edition</title>
  <style>
    body {
      font-family: Arial, Helvetica, sans-serif;
      background: #0a0a0a;
      color: #00ff41;
      margin: 0;
      padding: 30px;
      text-align: center;
    }
    h1 {
      font-size: 3.2rem;
      margin-bottom: 0.4em;
      text-shadow: 0 0 10px #00ff41;
    }
    .container {
      max-width: 900px;
      margin: 0 auto;
    }
    textarea, #output {
      width: 100%;
      min-height: 180px;
      font-size: 1.4rem;
      padding: 20px;
      border: 2px solid #00ff41;
      border-radius: 12px;
      background: #000;
      color: #00ff41;
      resize: vertical;
      box-sizing: border-box;
      margin: 20px 0;
      font-family: 'Courier New', Courier, monospace;
    }
    #output {
      background: #001100;
      min-height: 140px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .info {
      font-size: 1.1rem;
      opacity: 0.8;
      margin-top: 40px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ENGRISH TRANSRATOR<br>(Birrion & Herro Mode)</h1>

    <textarea id="input" placeholder="Type normal English here...&#10;Example: one billion dollars please"></textarea>

    <div id="output">Herro! Type something prease lah~</div>

    <div class="info">
      Real-time heavy Asian accent converter • L → R everywhere • lah~ sia~ ah? added • birrion special
    </div>
  </div>

  <script>
    const input = document.getElementById('input');
    const output = document.getElementById('output');

    function toEngrish(str) {
      if (!str.trim()) return 'Herro! Type something prease lah~';

      let t = str.toLowerCase();

      // Core heavy L/R swap – do this first and aggressively
      t = t.replace(/l/g, 'r');
      t = t.replace(/r/g, 'r'); // redundant but keeps pattern safe

      // Phonetic replacements (very heavy mode)
      t = t.replace(/th/g, 'z');              // think → zink, this → zis
      t = t.replace(/v/g, 'b');               // very → bery
      t = t.replace(/f([aeiou])/g, 'fu$1');   // friend → furiend, favorite → fuaborite
      t = t.replace(/s([aeiou])/g, 'su$1');   // sorry → surry, some → sum
      t = t.replace(/([aeiou])r([aeiou])/g, '$1ru$2'); // more → moru

      // Common word swaps
      t = t.replace(/\bthe\b/g, 'da');
      t = t.replace(/\band\b/g, 'an');
      t = t.replace(/\bis\b/g, 'iz');
      t = t.replace(/\bit\b/g, 'ito');
      t = t.replace(/\bthis\b/g, 'dis');
      t = t.replace(/\bthat\b/g, 'dat');
      t = t.replace(/\bwhat\b/g, 'watu');
      t = t.replace(/\bhow\b/g, 'hau');
      t = t.replace(/\bmy\b/g, 'mai');
      t = t.replace(/\byour\b/g, 'yua');
      t = t.replace(/\byou\b/g, 'yu');
      t = t.replace(/\byes\b/g, 'yesu');
      t = t.replace(/\bno\b/g, 'nooo');
      t = t.replace(/\btoo\b/g, 'tu');
      t = t.replace(/\blow\b/g, 'roo');
      t = t.replace(/\bvery\b/g, 'bery');
      t = t.replace(/\blove\b/g, 'robe');
      t = t.replace(/\bplease\b/g, 'prease');
      t = t.replace(/\bhello\b/g, 'herro');
      t = t.replace(/\bfriend\b/g, 'fwiend');
      t = t.replace(/\bmillion\b/g, 'mirrion');
      t = t.replace(/\bbillion\b/g, 'birrion');
      t = t.replace(/\bprice\b/g, 'plice');
      t = t.replace(/\bcoin\b/g, 'koin');
      t = t.replace(/\bgood\b/g, 'gud');
      t = t.replace(/\bthink\b/g, 'zink');
      t = t.replace(/\bshit\b/g, 'shitu');
      t = t.replace(/\bfuck\b/g, 'faku');

      // Grammar breakage & particles (heavy Singlish flavor)
      t = t.replace(/\s+i\s+/g, ' ai ');
      t = t.replace(/\s+me\s+/g, ' mi ');
      t = t.replace(/\s+you\s+/g, ' yu ');
      t = t.replace(/([a-z])\?$/g, '$1 ah?');
      t = t.replace(/([a-z])\.$/g, '$1 lah.');

      // Ending particles – always at least one, sometimes more
      const endings = [' lah~', ' sia~', ' ah?', ' hor~', ' leh~', ' one lah'];
      let ending = endings[0];
      if (Math.random() > 0.5) ending += endings[Math.floor(Math.random() * endings.length)];
      if (Math.random() > 0.7) ending += endings[Math.floor(Math.random() * endings.length)];

      t += ending;

      // Capitalize first letter (makes it look more sentence-like)
      t = t.charAt(0).toUpperCase() + t.slice(1);

      return t;
    }

    input.addEventListener('input', () => {
      output.textContent = toEngrish(input.value);
    });
  </script>
</body>
</html>